<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>第五章 Hibernate核心API介绍与其使用 | 笨笨个人笔记</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="/css/main.css?v=1.0.4"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body style="background:#fbfbfb;"><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">第五章 Hibernate核心API介绍与其使用</h1><a id="logo" href="/.">笨笨个人笔记</a><p class="description">ibenben.org</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">第五章 Hibernate核心API介绍与其使用</h1><div class="post-meta">May 27, 2013<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h2 id="5-1-Configuration接口5-1-1加载hibernate-cfg-xml并完成系统的配置"><a href="#5-1-Configuration接口5-1-1加载hibernate-cfg-xml并完成系统的配置" class="headerlink" title="5.1 Configuration接口5.1.1加载hibernate.cfg.xml并完成系统的配置"></a>5.1 Configuration接口5.1.1加载hibernate.cfg.xml并完成系统的配置</h2><pre><code>Configuration接口的作用是对Hibernate进行配置、并启动Hibernate和连接数据库系统。       在Hibernate的启动过程中，Configuration类的实例首先定位缺省XML配置文件（hibernate.cfg.xml），并读取关的配置项目，然后创建出一个SessionFactory对象。根5.1.2据Configuration对象创建一个SessionFactory对象。 ## 
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Configuration cfg = new Configuration();</span><br><span class="line">		cfg.configure();</span><br><span class="line">		SessionFactory sessionFactory = cfg.buildSessionFactory();</span><br></pre></td></tr></table></figure>
<p>5.1.3 也可以采用自定义的XML配置文件（少用）<br>        可以指定开发者自己的*.hbm.xml文件的位置，而不是使用默认的classpath下面的hibernate.cfg.xml。但需要在代码中指示开发者自定义的XML配置文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfg.configure(&quot;hibernate2.cfg.xml&quot;);</span><br></pre></td></tr></table></figure></p>
<h2 id="5-2-SessionFactory接口"><a href="#5-2-SessionFactory接口" class="headerlink" title="5.2 SessionFactory接口"></a>5.2 SessionFactory接口</h2><p>5.2.1 利用工厂类SessionFactory中取得Session的实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Session session = sessionFactory.openSession();</span><br></pre></td></tr></table></figure></p>
<p>5.2.2 SessionFactory并不是轻量级的<br>       但要注意的是SessionFactory并不是轻量级的！（占内存）<br>       实际上它的设计者的意图是让它能在整个应用中共享。</p>
<p>5.2.3 每个数据存储源对应创建一个SessionFactory（单例）</p>
<p>5.2.4 SessionFactory的缓存<br>       可分为两类：内置缓存和外置缓存。</p>
<p>5.2.4.1 SessionFactory的内置缓存中存放了Hibernate配置信息和映射元数据信息、同时也缓存了Hibernate自动生成的SQL语句等；</p>
<p>5.2.4.2 SessionFactory的外置缓存是一个可配置的缓存插件<br>       在默认情况下，SessionFactory不会启用这个缓存插件。<br>       外置缓存能存放大量数据库数据的拷贝，外置缓存的物理介质可以是内存或者硬盘。<br>5.3 Session接口</p>
<p>5.3.1轻量级的类<br>        在Hibernate中，实例化的Session是一个轻量级的类，创建和销毁它都不会占用很多资源。<br>        这在实际项目中确实很重要，因为在客户程序中，可能会不断地创建以及销毁Session对象，如果Session的开销太大，会给系统带来不良影响。</p>
<p>5.3.2非线程安全的(一请求—一线程—-一session—一事务)</p>
<p>值得注意的是Session对象是非线程安全的，因此最好是一个线程只创建一个Session对象（将它设计为局部对象）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static ThreadLocal threadSession = new ThreadLocal();</span><br><span class="line">public static Session getThreadLocalSession()&#123;</span><br><span class="line">		Session s = (Session) threadSession.get();</span><br><span class="line">		if(s == null)&#123;</span><br><span class="line">			s = sessionFactory.openSession();</span><br><span class="line">			threadSession.set(s);</span><br><span class="line">		&#125;</span><br><span class="line">		return s;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>5.3.3 Session看作介于数据连接与事务管理一种中间接口<br>       我们可以将session想象成一个持久对象的缓冲区，Hibernate能检测到这些持久对象的改变，并及时刷新数据库。</p>
<p>5.3.4 每一个Session实例和一个数据库事务绑定<br>       通常将每一个Session实例和一个数据库事务绑定，也就是说，每执行一个数据库事务（操作），都应该先创建一个新的Session实例。<br>       如果事务执行中出现异常，应该撤销事务；同时不论事务执行成功与否，最后都应该调用Session的close()方法，从而释放Session实例占用的资源。</p>
<p>5.3.5如何获得Session对象<br>       首先创建SessionFactory对象，应用程序如果访问多个数据源时，则应该产生多个SessionFactory；但是仅仅为了服务于某个请求时，不要创建一个新的     SessionFactory，因为创建SessionFactory 需要耗费大量的资源。</p>
<p>然后根据SessionFactory再创建Session对象</p>
<p>5.3.6 Session的编程规则—需要随时更新和释放<br>       注意：应该要session.close()语句放在finally语句块中。</p>
<p>5.3.7 Sessin 接口中针对单条记录的基本的CURD操作方法</p>
<p>1、save();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.save(Object);// session的save方法是向数据库中保存一个对象</span><br></pre></td></tr></table></figure></p>
<p>2、delete()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.delete(Object);//Object对象需要有ID。对象删除后，对象状态为Transistent状态</span><br></pre></td></tr></table></figure></p>
<p>3、load()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Session.load(Class arg0, Serializable arg1) throws HibernateException</span><br></pre></td></tr></table></figure></p>
<ul>
<li>arg0:需要加载对象的类，例如：User.class<em> arg1:查询条件(实现了序列化接口的对象)：例”4028818a245fdd0301245fdd06380001”字符串已经实现了序列化接口。如果是数值类类型，则hibernate会自动使用包装类，例如 1</em> 此方法返回类型为Object，但返回的是代理对象。<em> 执行此方法时不会立即发出查询SQL语句。只有在使用对象时，它才发出查询SQL语句，加载对象。</em> 因为load方法实现了lazy(称为延迟加载、赖加载)<em> 延迟加载：只有真正使用这个对象的时候，才加载(才发出SQL语句)</em> hibernate延迟加载实现原理是代理方式。* 采用load()方法加载数据，如果数据库中没有相应的记录，则会抛出异常对象不找到(org.hibernate.ObjectNotFoundException)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    session = sf.openSession();</span><br><span class="line">    session.beginTransaction();</span><br><span class="line">    User user = (User)session.load(User.class,1);</span><br><span class="line">    //只有在使用对象时，它才发出查询SQL语句，加载对象。</span><br><span class="line">    System.out.println(&quot;user.name=&quot; + user.getName());</span><br><span class="line"></span><br><span class="line">    //因为此的user为persistent状态，所以数据库进行同步为龙哥。</span><br><span class="line">    user.setName(&quot;发哥&quot;);</span><br><span class="line"></span><br><span class="line">    session.getTransaction().commit();</span><br><span class="line">&#125; catch (HibernateException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    session.getTransaction().rollback();</span><br><span class="line">&#125; finally&#123;</span><br><span class="line">    if (session != null)&#123;</span><br><span class="line">    if (session.isOpen())</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>4、Get()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Session.get(Class arg0, Serializable arg1)方法</span><br></pre></td></tr></table></figure></p>
<ul>
<li>arg0:需要加载对象的类，例如：User.class* arg1:查询条件(实现了序列化接口的对象)：<pre><code>例&quot;4028818a245fdd0301245fdd06380001&quot;字符串已经实现了序列化接口。如果是基数类型，则hibernate会自动转换成包装类，如 1        返回值： 此方法返回类型为Object，也就是对象，然后我们再强行转换为需要加载的对象就可以了。        如果数据不存在，则返回null;        注：执行此方法时立即发出查询SQL语句。加载User对象
加载数据库中存在的数据，代码如下：
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">     session = sf.openSession();</span><br><span class="line">     session.beginTransaction();</span><br><span class="line"></span><br><span class="line">     / * 此方法返回类型为Object，也就是对象，然后我们再强行转换为需要加载 的对象就可以了。如果数据不存在，则返回null</span><br><span class="line">       * 执行此方法时立即发出查询SQL语句。加载User对象。</span><br><span class="line">       */</span><br><span class="line">     User user = (User)session.get(User.class, 1);</span><br><span class="line"></span><br><span class="line">     //数据加载完后的状态为persistent状态。数据将与数据库同步。</span><br><span class="line">     System.out.println(&quot;user.name=&quot; + user.getName());</span><br><span class="line"></span><br><span class="line">     //因为此的user为persistent状态，所以数据库进行同步为龙哥。</span><br><span class="line">     user.setName(&quot;龙哥&quot;);</span><br><span class="line">  </span><br><span class="line">     session.getTransaction().commit();</span><br><span class="line">&#125; catch (HibernateException e) &#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line">     session.getTransaction().rollback();</span><br><span class="line">&#125; finally&#123;</span><br><span class="line">     if (session != null)&#123;</span><br><span class="line">     if (session.isOpen())&#123;</span><br><span class="line">         session.close();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>5、load()与get()区别<br>    不存在对应记录时表现不一样；<br>    load返回的是代理对象，等到真正使用对象的内容时才发出sql语句，这样就要求在第一次使用对象时，要求session处于open状态，否则出错<br>    get直接从数据库加载，不会延迟加载<br>    get()和load()只根据主键查询，不能根据其它字段查询，如果想根据非主键查询，可以使用HQL</p>
<p>6、update()<br>    用来更新detached对象，更新完成后转为为persistent状态(默认更新全部字段)<br>    更新transient对象会报错(没有ID)<br>    更新自己设定ID的transient对象可以(默认更新全部字段)<br>    persistent状态的对象，只要设定字段不同的值，在session提交时，会自动更新(默认更新全部字段)<br>    更新部分更新的字段(更改了哪个字段就更新哪个字段的内容)<br>    方法1：update/updatable属性<br>     xml：设定<property>标签的update属性，设置在更新时是否参数更新<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;name&quot; update=&quot;false&quot;/&gt;</span><br></pre></td></tr></table></figure></property></p>
<p>注意：update可取值为true(默认)：参与更新；false：更新时不参与更新<br>     annotateon:设定@Column的updatable属性值，true参与更新，false：不参与更新<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Column(updatable=false)</span><br><span class="line">public String getTitle() &#123;return title;&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：此种方法很少用，因为它不灵活<br>    方法二：dynamic-update属性<br>    注意：此方法目前只适合xml方式，JAP1.0 annotation没有对应的<br>    在实体类的映射文件中的<class>标签中，使用dynamic-update属性，true：表示修改了哪个字段就更新哪个字段，其它字段不更新，但要求是同一个session(不能跨session),如果跨了session同样会更新所有的字段内容。</class></p>
<p><class name="com.bjsxt.Student" dynamic-update="true"> 代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testUpdate5() &#123;</span><br><span class="line">Session session = sessionFactory.getCurrentSession();</span><br><span class="line">session.beginTransaction();</span><br><span class="line">Student s = (Student)session.get(Student.class, 1);</span><br><span class="line">s.setName(&quot;zhangsan5&quot;);</span><br><span class="line">//提交时，会只更新name字段，因为此时的s为persistent状态</span><br><span class="line">session.getTransaction().commit();</span><br><span class="line">s.setName(&quot;z4&quot;);</span><br><span class="line">Session session2 = sessionFactory.getCurrentSession();</span><br><span class="line">session2.beginTransaction();</span><br><span class="line">//更新时，会更新所有的字段，因为此时的s不是persistent状态</span><br><span class="line">session2.update(s);</span><br><span class="line">session2.getTransaction().commit();&#125;</span><br></pre></td></tr></table></figure></class></p>
<p>如果需要跨session实现更新修改的部分字段，需要使用session.merget()方法,合并字段内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testUpdate6() &#123;</span><br><span class="line">Session session = sessionFactory.getCurrentSession();</span><br><span class="line">session.beginTransaction();</span><br><span class="line">Student s = (Student)session.get(Student.class, 1);</span><br><span class="line">s.setName(&quot;zhangsan6&quot;);</span><br><span class="line">session.getTransaction().commit();</span><br><span class="line">s.setName(&quot;z4&quot;);</span><br><span class="line">Session session2 = sessionFactory.getCurrentSession();</span><br><span class="line">session2.beginTransaction();</span><br><span class="line">session2.merge(s);</span><br><span class="line">session2.getTransaction().commit()&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样虽然可以实现部分字段更新，但这样会多出一条select语句，因为在字段数据合并时，需要比较字段内容是否已变化，就需要从数据库中取出这条记录进行比较<br>使用HQL(EJBQL)面向对象的查询语言(建议)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testUpdate7() &#123;</span><br><span class="line">Session session = sessionFactory.getCurrentSession();</span><br><span class="line">session.beginTransaction();</span><br><span class="line">Query q = session.createQuery(</span><br><span class="line">&quot;update Student s set s.name=&apos;z5&apos; where s.id = 1&quot;);</span><br><span class="line">q.executeUpdate();</span><br><span class="line">session.getTransaction().commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>7、saveOrUpdate()<br>    在执行的时候hibernate会检查，如果对象在数据库中已经有对应的记录(是指主键)，则会更新update，否则会添加数据save</p>
<p>8、clear()<br>    清除session缓存<br>    无论是load还是get，都会首先查找缓存(一级缓存，也叫session级缓存)，如果没有，才会去数据库查找，调用clear()方法可以强制清除session缓存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Session session = sessionFactory.getCurrentSession();</span><br><span class="line">session.beginTransaction();</span><br><span class="line">Teacher t = (Teacher)session.load(Teacher.class, 1);</span><br><span class="line">System.out.println(t.getName());</span><br><span class="line">session.clear();</span><br><span class="line">Teacher t2 = (Teacher)session.load(Teacher.class, 1);</span><br><span class="line">System.out.println(t2.getName());</span><br><span class="line">session.getTransaction().commit();</span><br></pre></td></tr></table></figure></p>
<p>注意：这样就会发出两条SELECT语句，如果把session.clear()去除，则只会发出一条SELECT语句，因为第二次load时，是使用session缓存中ID为1的对象，而这个对象已经在第一次load到缓存中 了。<br>    9、flush()<br>    在hibernate中也存在flush这个功能，在默认的情况下session.commit()之前时，其实执行了一个flush命令。<br>    Session.flush功能：<br>    清理缓存；<br>    执行sql(确定是执行SQL语句(确定生成update、insert、delete语句等),然后执行SQL语句。)<br>    Session在什么情况下执行flush:<br>    默认在事务提交时执行；<br>    注意：flush时，可以自己设定,使用session.setFlushMode(FlushMode)来指定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   FlushMode的枚举值：</span><br><span class="line">    FlushMode.ALWAYS：任务一条SQL语句，都会flush一次</span><br><span class="line">    FlushMode.AUTO ：自动flush(默认)</span><br><span class="line">    FlushMode.COMMIT: 只有在commit时才flush</span><br><span class="line">FlushMode.MANUAL：手动flush。</span><br><span class="line">FlushMode.NEVER ：永远不flush  此选项在性能优化时可能用，比如session取数据为只读时用，这样就不需要与数据库同步了</span><br></pre></td></tr></table></figure>
<p>注意：设置flush模式时，需要在session开启事务之前设置。<br>可以显示的调用flush；<br>在执行查询前，如:iterate.<br>注：如果主键生成策略是uuid等不是由数据库生成的，则session.save()时并不会发出SQL语句，只有flush时才会发出SQL语句，但如果主键生成策略是native由数据库生成的，则session.save的同时就发出SQL语句。<br>10、evict()<br>例如：session.evict(user)<br>作用：从session缓存(EntityEntries属性)中逐出该对象<br>但是与commit同时使用，会抛出异常<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">session = HibernateUtils.getSession();</span><br><span class="line">tx = session.beginTransaction();</span><br><span class="line"></span><br><span class="line">User1 user = new User1();</span><br><span class="line">user.setName(&quot;李四&quot;);</span><br><span class="line">user.setPassword(&quot;123&quot;);</span><br><span class="line">user.setCreateTime(new Date());</span><br><span class="line">user.setExpireTime(new Date());</span><br><span class="line"></span><br><span class="line">//利用Hibernate将实体类对象保存到数据库中，因为user主键生成策略采用的是uuid，所以调用完成save后，只是将user纳入session的管理，不会发出insert语句，但是id已经生成，session中的existsInDatabase状态为false</span><br><span class="line">session.save(user);</span><br><span class="line"></span><br><span class="line">session.evict(user);//从session缓存(EntityEntries属性)中逐出该对象</span><br><span class="line">//无法成功提交，因为hibernate在清理缓存时，在session的临时集合(insertions)中取出user对象进行insert操作后需要更新entityEntries属性中的existsInDatabase为true,而我们采用evict已经将user从session中逐出了，所以找不到相关数据,无法更新，抛出异常。</span><br><span class="line"></span><br><span class="line">tx.commit();</span><br></pre></td></tr></table></figure></p>
<p>解决在逐出session缓存中的对象不抛出异常的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//在session.evict()之前进行显示的调用session.flush()方法就可以了。</span><br><span class="line">session.save(user);</span><br><span class="line"></span><br><span class="line">//flush后hibernate会清理缓存，会将user对象保存到数据库中，将session中的insertions中的user对象清除，并且会设置session中的existsInDatabase状态为false</span><br><span class="line">session.flush();</span><br><span class="line"></span><br><span class="line">session.evict(user);//从session缓存(EntityEntries属性)中逐出该对象</span><br><span class="line"></span><br><span class="line">//可以成功提交，因为hibernate在清理缓存时，在Session的insertions中集合中无法找到user对象所以不会发出insert语句，也不会更新session中existsInDatabase的状态。</span><br><span class="line">tx.commit();</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Transaction tx = null;</span><br><span class="line">	try&#123;</span><br><span class="line">		tx = session.beginTransaction();</span><br><span class="line">		session.save(obj);</span><br><span class="line">		tx.commit();</span><br><span class="line">	&#125;catch(HibernateException e)&#123;</span><br><span class="line">		if(tx != null)&#123;</span><br><span class="line">			tx.rollback();</span><br><span class="line">		&#125;</span><br><span class="line">		throw e;</span><br><span class="line">	&#125;finally&#123;</span><br><span class="line">		if(session != null)&#123;</span><br><span class="line">			session.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="tags"></div><div class="post-nav"><a href="/2013/05/27/8981608/" class="pre">第六章 Hibernate jar包</a><a href="/2013/05/23/8965844/" class="next">第四章 Hibernate中的持久化对象的生命周期</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2013-2018 <a href="/." rel="nofollow">笨笨个人笔记.</a></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=1.0.4" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.4" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.4"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.4"></script><script type="text/javascript" src="/js/prism.js?v=1.0.4"></script></div></body></html>