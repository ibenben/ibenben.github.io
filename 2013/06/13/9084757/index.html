<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>第十二章 hibernate缓存 | 笨笨个人笔记</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="/css/main.css?v=1.0.4"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body style="background:#fbfbfb;"><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">第十二章 hibernate缓存</h1><a id="logo" href="/.">笨笨个人笔记</a><p class="description">ibenben.org</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">第十二章 hibernate缓存</h1><div class="post-meta">Jun 13, 2013<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h2 id="1、一级缓存（Session级缓存）"><a href="#1、一级缓存（Session级缓存）" class="headerlink" title="1、一级缓存（Session级缓存）"></a>1、一级缓存（Session级缓存）</h2><p>一级缓存很短和session的生命周期一致，因此也叫session级缓存或事务级缓存</p>
<p>那些方法支持一级缓存：</p>
<p>*get()</p>
<p>*load()</p>
<p>*iterate（查询实体对象）</p>
<p>如何管理一级缓存：</p>
<p>*session.clear(),session.evict()</p>
<p>如何避免一次性大量的实体数据入库导致内存溢出<br><strong>方法１：先</strong></p>
<p><strong>，再</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0; i &lt;1000000; i++)&#123;</span><br><span class="line">		session.save(user);</span><br><span class="line">		if(i % 20 == 0)&#123;</span><br><span class="line">			session.flush();</span><br><span class="line">			session.clear();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法２：用</strong></p>
<p>Hibernate提供了基于命令的API，可以用detachedobject（分离对象）的形式把数据以流的方法加入到数据库，或从数据库输出。StatelessSession没有持久化上下文，也不提供多少高层的生命周期语义。特别是，无状态session不实现第一级cache,也不和第二级缓存，或者查询缓存交互。用StatelessSession进行的操作甚至不级联到关联实例。</p>
<p>无状态session是低层的抽象，和低层JDBC相当接近。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StatelessSession statelessSession = sessionFactory.openStatelessSession();</span><br><span class="line">		statelessSession.insert(user);</span><br></pre></td></tr></table></figure>
<p>方法３：批量更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">session.beginTransaction();</span><br><span class="line">Queryquery = session.createQuery(&quot;updateUser as u set u.password=:p&quot;);</span><br><span class="line">query.setString(&quot;p&quot;,&quot;000000&quot;);</span><br><span class="line">query.executeUpdate();</span><br><span class="line">session.getTransaction().commit();</span><br></pre></td></tr></table></figure>
<p>如果数据量特别大，考虑采用jdbc实现，如果jdbc也不能满足要求可以考虑采用数据本身的特定导入工具</p>
<h2 id="2、二级缓存"><a href="#2、二级缓存" class="headerlink" title="2、二级缓存"></a>2、二级缓存</h2><p>Hibernate默认的二级缓存是开启的。</p>
<p>二级缓存也称为进程级的缓存，也可称为SessionFactory级的缓存(因为SessionFactory可以管理二级缓存)，它与session级缓存不一样，一级缓存只要session关闭缓存就不存在了。而二级缓存则只要进程在二级缓存就可用。</p>
<p>二级缓存可以被所有的session共享</p>
<p>二级缓存的生命周期和SessionFactory的生命周期一样，SessionFactory可以管理二级缓存</p>
<p>二级缓存同session级缓存一样，只缓存实体对象，普通属性的查询不会缓存</p>
<p>二级缓存一般使用第三方的产品，如EHCache</p>
<h2 id="2-1常见缓存提供商"><a href="#2-1常见缓存提供商" class="headerlink" title="2.1常见缓存提供商"></a>2.1常见缓存提供商</h2><table>
<thead>
<tr>
<th>Cache</th>
<th>Providerclass</th>
<th>Type</th>
<th>ClusterSafe</th>
<th>QueryCache Supported</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hashtable(not intended for production use)</td>
<td>org.hibernate.cache.HashtableCacheProvider</td>
<td>memory</td>
<td>-</td>
<td>yes</td>
</tr>
<tr>
<td>EHCache</td>
<td>org.hibernate.cache.EhCacheProvider</td>
<td>memory,disk</td>
<td>-</td>
<td>yes</td>
</tr>
<tr>
<td>OSCache</td>
<td>org.hibernate.cache.OSCacheProvider</td>
<td>memory,disk</td>
<td>-</td>
<td>yes</td>
</tr>
<tr>
<td>SwarmCache</td>
<td>org.hibernate.cache.SwarmCacheProvider</td>
<td>clustered(ip multicast)</td>
<td>yes(clustered invalidation)</td>
<td>-</td>
</tr>
<tr>
<td>JBossTreeCache</td>
<td>org.hibernate.cache.TreeCacheProvider</td>
<td>clustered(ip multicast), transactional</td>
<td>yes(replication)</td>
<td>yes(clock sync req.)</td>
</tr>
</tbody>
</table>
<h2 id="2-2二级缓存的用法"><a href="#2-2二级缓存的用法" class="headerlink" title="2.2二级缓存的用法"></a>2.2二级缓存的用法</h2><p>这里以常见的EHCache为例</p>
<p><strong>(1)在hibernate.cfg.xml中开启二级缓存。</strong></p>
<p>设置启用二级缓存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;propertyname=&quot;hibernate.cache.use_second_level_cache&quot;&gt;true&lt;/property&gt;</span><br></pre></td></tr></table></figure>
<p>设置二级缓存的实现类(缓存提供商)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;propertyname=&quot;hibernate.cache.provider_class&quot;&gt;org.hibernate.cache.EhCacheProvider</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>
<p><strong>(2)导入所使用的二级缓存JAR包</strong></p>
<p>ehcache-1.2.3.jar、commons-logging.jar、commons-logging-1.0.4.jar</p>
<p><strong>(3)src下写缓存配置文件：ehcache.xml</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;ehcache&gt;</span><br><span class="line">	&lt;diskStore path=&quot;C:\\cache&quot; /&gt;</span><br><span class="line">	&lt;defaultCache </span><br><span class="line">		maxElementsInMemory=&quot;10000&quot;</span><br><span class="line">	   　 eternal=&quot;false&quot;</span><br><span class="line">		overflowToDisk=&quot;true&quot; </span><br><span class="line">		timeToIdleSeconds=&quot;120&quot; </span><br><span class="line">		timeToLiveSeconds=&quot;120&quot;</span><br><span class="line">		diskPersistent=&quot;false&quot; /&gt;</span><br><span class="line">&lt;/ehcache&gt;</span><br></pre></td></tr></table></figure>
<p>maxElementsInMemory属性用于指定缓存中最多可放多少个对象。</p>
<p>overflowToDisk当内存中缓存的记录达到maxElementsInMemory时是否被持久化到硬盘中。保存路径由diskStore决定的<br>eternal属性指定缓存是否永久有效。<br>timeToIdleSeconds属性指定缓存多久未被使用便清理掉。<br>timeToLiveSeconds属性指定缓存的生命长度。<br>diskPersistent属性指定缓存是否被持久化到硬盘中，保存路径由diskStore标签指定。<br><strong>(4)设置所有缓存的实体类</strong></p>
<p>a、hibernate.cfg.xml中设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;class-cacheclass=&quot;cn.ineeke.entity.User&quot;usage=&quot;read-only&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>b、*.hbm.xml中设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;hibernate-mapping&gt;</span><br><span class="line">    &lt;class name=&quot;cn.framelife.hibernate.entity.User&quot; table=&quot;user&quot; catalog=&quot;hibernate&quot;&gt;</span><br><span class="line">        &lt;cache usage=&quot;read-only&quot;/&gt;</span><br><span class="line">        &lt;id name=&quot;id&quot; type=&quot;java.lang.Integer&quot;&gt;</span><br><span class="line">            &lt;column name=&quot;id&quot; /&gt;</span><br><span class="line">            &lt;generator class=&quot;native&quot; /&gt;</span><br><span class="line">        &lt;/id&gt;</span><br><span class="line">        &lt;property name=&quot;username&quot; type=&quot;java.lang.String&quot;&gt;</span><br><span class="line">            &lt;column name=&quot;username&quot; length=&quot;45&quot; not-null=&quot;true&quot; /&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; type=&quot;java.lang.String&quot;&gt;</span><br><span class="line">            &lt;column name=&quot;password&quot; length=&quot;45&quot; not-null=&quot;true&quot; /&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/class&gt;</span><br><span class="line">&lt;/hibernate-mapping&gt;</span><br></pre></td></tr></table></figure></p>
<p>c、Annotation方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Cache(usage=CacheConcurrencyStrategy.READ_ONLY)</span><br><span class="line">@Table(name = &quot;user&quot;, catalog = &quot;hibernate&quot;)</span><br><span class="line">public class User implements java.io.Serializable &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>d、缓存策略</p>
<p>只读缓存（read-only）：没有什么好说的 ,最常用也最简单的。读/写缓存（read-write）:程序可能要的更新数据 不严格的读/写缓存（nonstrict-read-write）：需要更新数据，但是两个事务更新同一条记录的可能性很小，性能比读写缓存好 事务缓存（transactional）：缓存支持事务，发生异常的时候，缓存也能够回滚，只支持jta环境。 读写缓存和不严格读写缓存在实现上的区别在于，读写缓存更新缓存的时候会把缓存里面的数据换成一个锁，其他事务如果去取相应的缓存数据，发现被锁住了，然后就直接取数据库查询。 在hibernate2.1的ehcache实现中，如果锁住部分缓存的事务发生了异常，那么缓存会一直被锁住，直到60秒后超时。 不严格读写缓存不锁定缓存中的数据。<br><strong>(5)测试</strong></p>
<p><strong>测试代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; uesrs = session.createQuery(&quot;from User&quot;).list();</span><br><span class="line">			System.out.println(&quot;--------------&quot;);</span><br><span class="line">			Session s2 = sessionFactory.openSession();</span><br><span class="line">			User user = (User) s2.get(User.class, 2);</span><br><span class="line">			System.out.println(user.getUsername());</span><br></pre></td></tr></table></figure>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: select user0_.id as id0_, user0_.first_name as first2_0_, user0_.last_name as last3_0_, user0_.password as password0_, user0_.username as username0_ from hibernate.user user0_</span><br><span class="line">--------------</span><br><span class="line">zhangsan</span><br></pre></td></tr></table></figure></p>
<h2 id="2-3打开二级缓存统计信息"><a href="#2-3打开二级缓存统计信息" class="headerlink" title="2.3打开二级缓存统计信息"></a>2.3打开二级缓存统计信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; uesrs = session.createQuery(&quot;from User&quot;).list();</span><br><span class="line">			System.out.println(&quot;--------------&quot;);</span><br><span class="line">			Session s2 = sessionFactory.openSession();</span><br><span class="line">			User user = (User) s2.get(User.class, 2);</span><br><span class="line">			System.out.println(user.getUsername());</span><br><span class="line">			</span><br><span class="line">			Statistics st = sessionFactory.getStatistics();</span><br><span class="line">			System.out.println(st);</span><br><span class="line">						    System.out.println(st.getSecondLevelCacheStatistics(&quot;cn.framelife.hibernate.entity.User&quot;).getEntries());</span><br></pre></td></tr></table></figure>
<h2 id="3、查询缓存"><a href="#3、查询缓存" class="headerlink" title="3、查询缓存"></a>3、查询缓存</h2><p>hibernate的查询缓存是主要是针对普通属性结果集的缓存，而对于实体对象的结果集只缓存id。在一级缓存,二级缓存和查询缓存都打开的情况下作查询操作时这样的：查询普通属性，会先到查询缓存中取，如果没有，则查询数据库；查询实体（对象），会先到查询缓存中取id，如果有，则根据id到缓存(一级/二级)中取实体（对象），如果缓存中取不到实体，再查询数据库。</p>
<p>查询缓存的生命周期，是不确定的，当前关联的表发生改变时，查询缓存的生命周期结束。<br><strong>配置和使用：</strong></p>
<p>查询缓存的配置和使用也是很简单的：<br>        1&gt;查询缓存的启用不但要在配置文件中进行配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;propertyname=&quot;hibernate.cache.use_query_cache&quot;&gt;true&lt;/property&gt;</span><br></pre></td></tr></table></figure></p>
<p>2&gt;还要在程序中显示的进行启用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query.setCacheable(true);</span><br></pre></td></tr></table></figure></p>
<p><strong>测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Query query = session.createQuery(&quot;select u.username from User u where u.id &gt; 210&quot;);</span><br><span class="line">		//query.setCacheable(true);</span><br><span class="line">		List&lt;String&gt; names = query.list();</span><br><span class="line">		for (String name : names) &#123;</span><br><span class="line">			System.out.println(name);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;================================&quot;);</span><br><span class="line">		query = session.createQuery(&quot;select u.username from User u where u.id &gt; 210&quot;);</span><br><span class="line">		//query.setCacheable(true);</span><br><span class="line">		names = query.list();</span><br><span class="line">		for (String name : names) &#123;</span><br><span class="line">			System.out.println(name);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>没开启查询缓存（query.setCacheable(false)）时的结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: select user0_.username as col_0_0_ from hibernate.user user0_ where user0_.id&gt;210</span><br><span class="line">abcd</span><br><span class="line">1111</span><br><span class="line">11111</span><br><span class="line">================================</span><br><span class="line">Hibernate: select user0_.username as col_0_0_ from hibernate.user user0_ where user0_.id&gt;210</span><br><span class="line">abcd</span><br><span class="line">1111</span><br><span class="line">11111</span><br></pre></td></tr></table></figure></p>
<p>一模一样的查询，执行了两次SQL。</p>
<p><strong>：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: select user0_.username as col_0_0_ from hibernate.user user0_ where user0_.id&gt;210</span><br><span class="line">abcd</span><br><span class="line">1111</span><br><span class="line">11111</span><br><span class="line">================================</span><br><span class="line">abcd</span><br><span class="line">1111</span><br><span class="line">11111</span><br></pre></td></tr></table></figure>
<p>开启查询缓存后，一模一样两次的查询，只需要执行一次sql。</p>
<p>注意：</p>
<p>当只是用Hibernate查询缓存，而关闭二级缓存的时候：</p>
<p>第一：如果查询的是部分属性结果集：</p>
<p>那么当第二次查询的时候就不会发出SQL直接从Hibernate查询缓存中取数据</p>
<p>第二：如果查询的是实体结果集eg(fromStudent)<br>这个HQL那么查询出来的实体，首先Hibernate查询缓存存放实体的ID，</p>
<p>第二次查询的时候就到Hibernate查询缓存中取出ID一条一条的到数据库查询这样<br> 将发出N条SQL造成了SQL泛滥</p>
<p>在只打开查询缓存，关闭二级缓存的情况下，不要去查询实体对象。这样会造成很大的资源浪费。</p>
<p>当都开启Hibernate查询缓存和二级缓存的时候</p>
<p>第一：如果查询的是部分属性结果集：这个和上面只是用Hibernate查询缓存而关闭<br> 二级缓存的时候，一致 因为不涉及实体不会用到二级缓存</p>
<p>第二：如果查询的是实体结果集eg(fromStudent)<br>这个HQL那么查询出来的实体，首先Hibernate查询缓存存放实体的ID，第二次查询，的时候就到Hibernate查询缓存中取出ID,拿到二级缓存区找数据，如果有数据就不会发出SQL如果都有一条SQL都不会发出直接从二级缓存中取数据</p>
<p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">		 * 开启查询缓存,开启二级缓存, 开启两个session,分别调用query.list查询实体对象</span><br><span class="line">		 */</span><br><span class="line">		// 如果不用查询缓存的话,那两个都发出查询语句,这也是默认的情况.</span><br><span class="line">		try &#123;</span><br><span class="line">			session = sessionFactory.openSession();</span><br><span class="line">			t = session.beginTransaction();</span><br><span class="line">			Query query = session.createQuery(&quot;from User as u where u.id &lt; 90&quot;);</span><br><span class="line">			// 启用查询缓存</span><br><span class="line">			query.setCacheable(true);</span><br><span class="line">			List&lt;User&gt; list = query.list();</span><br><span class="line">			for (User user : list) &#123;</span><br><span class="line">				System.out.println(user.getUsername());</span><br><span class="line">			&#125;</span><br><span class="line">			t.commit();</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			t.rollback();</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			session.close();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;================================&quot;);</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			session = sessionFactory.openSession();</span><br><span class="line">			t = session.beginTransaction();</span><br><span class="line">			Query query = session.createQuery(&quot;from User as u where u.id &lt; 90&quot;);</span><br><span class="line">			// 启用查询缓存</span><br><span class="line">			query.setCacheable(true);</span><br><span class="line">			// 不会发出查询语句,因为这种情况下,查询过程是这样的：</span><br><span class="line">			// 在第一次执行list时,会把查询对象的id缓存到查询缓存里</span><br><span class="line">			// 第二次执行list时, 会遍历查询缓存里的id到缓存里去找实体对象,由于这里开启了二级缓存,可以找到目标实体对象,</span><br><span class="line">			// 所以就不会再发出n条查询语句.</span><br><span class="line">			List&lt;User&gt; list = query.list();</span><br><span class="line">			for (User user : list) &#123;</span><br><span class="line">				System.out.println(user.getUsername());</span><br><span class="line">			&#125;</span><br><span class="line">			t.commit();</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			t.rollback();</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			session.close();</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4集群缓存"><a href="#4集群缓存" class="headerlink" title="4集群缓存"></a>4集群缓存</h2><h2 id="5中央缓存"><a href="#5中央缓存" class="headerlink" title="5中央缓存"></a>5中央缓存</h2><h2 id="6使用缓存的条件"><a href="#6使用缓存的条件" class="headerlink" title="6使用缓存的条件"></a>6使用缓存的条件</h2><h2 id="7注意事项"><a href="#7注意事项" class="headerlink" title="7注意事项"></a>7注意事项</h2><p>不要想当然的以为缓存一定能提高性能，仅仅在你能够驾驭它并且条件合适的情况下才是这样的。hibernate的二级缓存限制还是比较多的，不方便用jdbc可能会大大的降低更新性能。在不了解原理的情况下乱用，可能会有1+N的问题。不当的使用还可能导致读出脏数据。<br>        如果受不了hibernate的诸多限制，那么还是自己在应用程序的层面上做缓存吧。<br>        在越高的层面上做缓存，效果就会越好。就好像尽管磁盘有缓存，数据库还是要实现自己的缓存，尽管数据库有缓存，咱们的应用程序还是要做缓存。因为底层的缓存它并不知道高层要用这些数据干什么，只能做的比较通用，而高层可以有针对性的实现缓存，所以在更高的级别上做缓存，效果也要好些吧。</p>
</div><script type="text/javascript" src="/js/share.js?v=1.0.4" async></script><a data-url="http://ibenben.org/2013/06/13/9084757/" data-id="cjozgqnom00li6gv8c30ltx5o" class="article-share-link">分享</a><div class="tags"></div><div class="post-nav"><a href="/2013/06/13/9085925/" class="pre">第十三章 事务并发处理</a><a href="/2013/06/13/9083715/" class="next">第十一章 Hibernate的查询 本地SQL查询</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2013-2018 <a href="/." rel="nofollow">笨笨个人笔记.</a></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=1.0.4" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.4" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.4"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.4"></script><script type="text/javascript" src="/js/prism.js?v=1.0.4"></script></div></body></html>