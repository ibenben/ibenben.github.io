<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>javaer to go之基础 | 笨笨个人笔记</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="/css/main.css?v=1.0.4"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body style="background:#fbfbfb;"><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">javaer to go之基础</h1><a id="logo" href="/.">笨笨个人笔记</a><p class="description">ibenben.org</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">javaer to go之基础</h1><div class="post-meta">Mar 29, 2016<span> | </span><span class="category"><a href="/categories/golang/">golang</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h2 id="1、开始"><a href="#1、开始" class="headerlink" title="1、开始"></a>1、开始</h2><p>我是一个javaer,最近空闲时间在学习golang。</p>
<p>度娘后，安装好Go环境和LiteIDE后，一开始我也没从基础开始看，而是想把现有的java项目改成是golang版本的。</p>
<p>原项目内容：</p>
<ol>
<li>socket模块接收下位机的数据</li>
<li>对协议数据进行解析</li>
<li>把协议数据解析后存进数据库</li>
<li>web子项目</li>
</ol>
<p>golang相比java，有很多很方便的特性。特别是并发与网络方面更是golang的卖点。所以我就直接找了个socket的例子开始模拟着实现项目的socket模块</p>
<h2 id="2、第一个程序"><a href="#2、第一个程序" class="headerlink" title="2、第一个程序"></a>2、第一个程序</h2><p>server.go :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">package socket</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;net&quot;</span><br><span class="line">    &quot;strings&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func  StartServer() &#123;</span><br><span class="line">    service := &quot;:3338&quot;</span><br><span class="line">    tcpAddr, err := net.ResolveTCPAddr(&quot;tcp4&quot;, service)</span><br><span class="line">    checkError(err)</span><br><span class="line">    listener, err := net.ListenTCP(&quot;tcp&quot;, tcpAddr)</span><br><span class="line">    checkError(err)</span><br><span class="line">    for &#123;</span><br><span class="line">        conn, err := listener.Accept()</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            continue</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(&quot;新连接：&quot;, conn.RemoteAddr().String())</span><br><span class="line">        go handleConn(conn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func handleConn(conn net.Conn) &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        buffer := make([]byte, 1024)</span><br><span class="line"></span><br><span class="line">        length, err := conn.Read(buffer)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            conn.Close()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if length &gt; 12 &#123;</span><br><span class="line">            data := buffer[:length]</span><br><span class="line"></span><br><span class="line">            switch data[11] &amp; 0xff &#123;</span><br><span class="line">            case 0x80:</span><br><span class="line">                //桌子</span><br><span class="line">                fmt.Println(&quot;桌子&quot;)</span><br><span class="line">            case 0x90:</span><br><span class="line">                //椅子</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            case 0xA0:</span><br><span class="line">                //台灯</span><br><span class="line"></span><br><span class="line">            default:</span><br><span class="line">                //其它</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //写数据</span><br><span class="line"></span><br><span class="line">            //      conn.Write(data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func isProtocol(data []byte) bool &#123;</span><br><span class="line">    if (data[0]&amp;0xff) == 0xC0 &amp;&amp; (data[len(data)-1]&amp;0xff) == 0xC1 &#123;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">    return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func checkError(err error) &#123;</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Println(err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为是第一篇笔记，也简单地说一下golang的基础语法。</p>
<p>对于一个javaer来说，或者一个有计算机语言基础的朋友来说，golang的语法看起来不会太困难。</p>
<h2 id="3、包路径"><a href="#3、包路径" class="headerlink" title="3、包路径"></a>3、包路径</h2><p>像java一样，一开始我们为程序声明一个包路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package socket</span><br></pre></td></tr></table></figure></p>
<p>和java不一样的是，golang的包不是层叠式的。所以为了方便识别我们也可以为我们所有的项目放到一个父包下。</p>
<p>类似与java，我这里使用了一个letus.xyz的命名作为父包（文件夹）。这样其它的程序就能比较方便地找到server.go程序来调用。</p>
<p><img src="/img/article/20160329170333576.png" alt="这里写图片描述"></p>
<blockquote>
<p>如果想要构建一个程序，则包和包内的文件都必须以正确的顺序进行编译。包的依赖关系决定了其构建顺序。属于同一个包的源文件必须全部被一起编译，一个包即是编译时的一个单元，因此根据惯例，每个目录都只包含一个包。如果对一个包进行更改或重新编译，所有引用了这个包的客户端程序都必须全部重新编译。</p>
</blockquote>
<h2 id="4、包与库的导入"><a href="#4、包与库的导入" class="headerlink" title="4、包与库的导入"></a>4、包与库的导入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;net&quot;</span><br><span class="line">    &quot;strings&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>和java相比，golang使用的这种方式进行导包和库看起来优雅多了。</p>
<p>当然，你也可以像java一样，一个一个地import<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &quot;fmt&quot;    </span><br><span class="line">import  &quot;net&quot;</span><br><span class="line">import  &quot;strings&quot;</span><br></pre></td></tr></table></figure></p>
<p>注意事项：</p>
<blockquote>
<p>如果你导入了一个包却没有使用它，则会在构建程序时引发错误，如 imported and not used: os，这正是遵循了 Go 的格言：“没有不必要的代码！“。当你导入多个包时，导入的顺序会按照字母排序。如果包名不是以 . 或 / 开头，如 “fmt” 或者 “container/list”，则 Go 会在全局文件进行查找；如果包名以 ./ 开头，则 Go 会在相对目录中查找；如果包名以 / 开头（在 Windows 下也可以这样使用），则会在系统的绝对路径中查找。导入包即等同于包含了这个包的所有的代码对象。除了符号 _，包中所有代码对象的标识符必须是唯一的，以避免名称冲突。但是相同的标识符可以在不同的包中使用，因为可以使用包名来区分它们。</p>
</blockquote>
<h2 id="5、-函数"><a href="#5、-函数" class="headerlink" title="5、 函数"></a>5、 函数</h2><p>导入包和库之后，就是我们的程序主体了。当然，我们写程序的时候肯定是package之后就直接写程序主体，而包与库是到用到这个包内容的时候再导。</p>
<p>golang和c一样，是面向过程的函数式编程，而不是java那样的面向对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func  StartServer() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func isProtocol(data []byte) bool &#123;</span><br><span class="line"></span><br><span class="line">    return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func checkError(err error) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>可见性规则：当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 private ）。</p>
</blockquote>
<p>函数的基本结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func functionName(parameter_list) (return_value_list) &#123;</span><br><span class="line">   …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中：</p>
<ul>
<li>参数：parameter_list 的形式为 (param1 type1, param2 type2, …)</li>
<li>返回类型return_value_list 的形式为 (ret1 type1, ret2 type2, …)</li>
</ul>
<p>golang的方法比java有意思的是它允许返回多个值。而它的参数表示形式与java也不一样，名字是放在类型的前面。</p>
<h2 id="6、变量"><a href="#6、变量" class="headerlink" title="6、变量"></a>6、变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service := &quot;:3338&quot;</span><br></pre></td></tr></table></figure>
<p>:=是简短声明语法 ，表示声明并赋值。<br>或者你也可以用var来声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var service = &quot;:3338&quot;</span><br></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var service string</span><br><span class="line">service = &quot;:3338&quot;</span><br></pre></td></tr></table></figure></p>
<p>简短声明法看起来更加优雅些。</p>
<h2 id="7、常量"><a href="#7、常量" class="headerlink" title="7、常量"></a>7、常量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    Unknown = 0</span><br><span class="line">    Female = 1</span><br><span class="line">    Male = 2</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>我们第一个程序没用到常量。常量是通过const来定义的。</p>
<p>常量的定义格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const identifier [type] = value</span><br></pre></td></tr></table></figure></p>
<h2 id="8、基本数据类型"><a href="#8、基本数据类型" class="headerlink" title="8、基本数据类型"></a>8、基本数据类型</h2><ul>
<li>int，Runes（注：Rune 是int 的别名）</li>
<li>int8 ,int16 ,int32 ,int64</li>
<li>byte ,uint8 ,uint16 ,uint32 ,uint64 （注：byte是uint8 的别名）</li>
<li>float32 ，float64 (没有float 类型)</li>
<li>bool</li>
<li>string</li>
<li><p>complex128，complex64</p>
<h2 id="9、main函数"><a href="#9、main函数" class="headerlink" title="9、main函数"></a>9、main函数</h2></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;letus.xyz/socket&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    socket.StartServer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们通过绝对路径letus.xyz主包找到socket包来调用程序。当然我们也可以相对目录导入。很明显，相对路径的方式不利于包的复用。</p>
<p>所以个人建议使用绝对路径来导包，毕竟思想上和java相似。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;../socket&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h2 id="10、其它"><a href="#10、其它" class="headerlink" title="10、其它"></a>10、其它</h2><p>golang的运算符与控制结构语句的使用基本和java的一样，但值得一提的是，golang的switch语法支持字符串的匹配。这是作为一个javaer经常想java也提供的一个特性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">switch field.Type().String() &#123;</span><br><span class="line">case &quot;time.Time&quot;:</span><br><span class="line">    v, _ := time.Parse(&quot;2006-01-02 15:04:05&quot;, s)</span><br><span class="line">    field.Set(reflect.ValueOf(v))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</div><div class="tags"><a href="/tags/java/">java</a><a href="/tags/golang/">golang</a><a href="/tags/socket/">socket</a><a href="/tags/基础/">基础</a><a href="/tags/数据/">数据</a></div><div class="post-nav"><a href="/2016/03/30/51008137/" class="pre">javaer to go之TCP Socket与Goroutine</a><a href="/2016/03/15/50886981/" class="next">Java Collection笔记之ArrayList</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2013-2018 <a href="/." rel="nofollow">笨笨个人笔记.</a></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=1.0.4" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.4" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.4"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.4"></script><script type="text/javascript" src="/js/prism.js?v=1.0.4"></script></div></body></html>